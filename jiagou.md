# 架构

## 分层架构

1. 用户界面层
2. 应用层
3. 领域层
4. 基础设施层

原则: 每层只能与位于其下方的层发生耦合。
分层架构分两种

-  严格分层架构 某层只能与直接位于其下方的层发生耦合。
-  松散分层架构 允许任意上方的层与其任意下方的层发生耦合。
  
由于用户界面层和应用服务层通常需要和基础设施层打交道，许多系统都是基于松散分层架构

事实上 较低层也可以和较高层发生耦合，但只局限于采用 __观察者模式__ 或者调停者模式。较低层绝对不能直接访问较高层的。

## 命令与查询职责分离- CQRS

解释： 一个方法要么是执行某种动作的命令，要么是返回数据的查询，而不能两者皆是。
在对象层面:
  1. 如果一个方法修改了对象的状态，该方法便是一个命令。它不应该返回数据。

  2. 如果一个方法反悔了数据，该方法便是一个查询，此时他不应该直接或间接的手段修改对象状态。

- 命令模型 只有add 和save 方法（分别支持创建和更新）,同时只有一个查询方法，比如fromId() 返回该聚合实例。资源库不能使用其他方法进行查询，比如对属性进行过滤。
-  查询模型

CQRS 旨在解决数据显示复杂性问题。
因此领域模型将被一分为二，命令模型和查询模型分开进行存储。


## 实体
### 为什么需要实体
需要考虑一个对象的个性特征，或者需要区分不同的对象时，我们引入实体这个领域概念。一个实体是一个唯一的东西，并且可以持续变化，可以对实体多次修改。
唯一的身份标识黑人可变性特征将实体对象和值对象区分开来。
### 唯一标识

常用的创建实体身份标识的策略，从简单到复杂

- 用户提供一个或多个初始唯一值作为程序输入
- 程序内部通过某种算法自动生成身份标识，通过类库或框架，或者程序自己生成
- 程序依赖于持久化存储，比如数据库，来生成唯一标识。
- 另一个限界上下文(系统或者程序） 已经决定出了唯一标识

#### 用户提供唯一标识副作用
复杂性之一便是需要用户自己生成高质量的标识，此时标识可能是唯一的，但却有可能是不正确的。
#### 应用程序生成唯一标识

其中的一种生成方法
1. 计算节点的当前时间， 以毫秒计
2. 计算节点的IP 地址
3. 虚拟机(java) 中工厂对象实例的对象标识
4. 虚拟机(java) 中由同一个随机数生成器生成的随机数

以上产生128位的唯一值，可以用连字符 -  连起来。不连的话就是32 字节的字符串
##### 委派标识
创建一个委派标识被ORM用，通常委派标识采用long 或int 类型。就是数据库里的id,主键。对于外界来说， 最好将委派标识隐藏起来，委派标识不是领域模型的一部分，而将委派标识暴露给外界可能造成持久化漏洞。


##### 验证
自封装

比如


```
type User struct {
	Addr string
}

func (u *User) SetAddr(addr string) error{
	if addr == "" {
		return errors.New("")
	}
	if len(addr) < 255 {
		return errors.New("")
	}

	u.Addr = addr
	return nil
}

```

### 值对象


尽量使用值对象来建模而不是实体对象
如何确定一个领域对象建模成一个值对象还是实体
#### 值对象的特征
1. 度量或者描述了领域中的一件东西
2. 它可以作为不变量
3. 他将不同的相关的属性组合成一个概念整体
4. 当度量或者描述改变时，可以用另一个值对象替换
5. 它可以和其他值对象进行相等性比较
6. 它不会对协助对象造成副作用

#### 度量或者描述
用来度量或者描述领域中某件东西的一个概念。比如年龄，名字
#### 不变性
值对象的任何方法都必须是private 的，外界不能调用
#### 概念整体

一个值对象可以只处理单个属性，也可以处理一组相关联的属性。在这组相关联的属性中，每一个属性都是整体属性所不可或缺的组成部分。如果一组属性联合起来不能表达一个整体上的概念，那这种联合并不多大用处。


比如 值对象 {500000美元} 有两个属性，一个是500000，一个是美元。只有将两者联合起来才能表达货币度量的整体概念。

#### 可替换性

通过数字来理解

```
var total int = 3

....

total = 4

```

##### 值对象相等性

Equal(otherObject) 方法 在java 中，equal() 方法经常和hashCode() 方法同时出现

思考设计的概念是否必须用实体来实现，是否从值对象中农得到了足够的支持？如果该概念不需要唯一标识，那么请将其建模成一个值对象

#### 无副作用行为

无副作用函数： 表示对某个对象的发哦做，它只用于产生输出去，而不会修改对象的状态。对于不变的值对象而言，所有的方法必须是无副作用函数。因为他们不能破坏值对象的不变性。
命令查询分离(CQS) 原则将无副作用函数描述为 查询方法。一个查询方法即向某个对象问一个问题，问题不应该对答案进行修改。

一个值对象不应该对传入的实体对象进行修改

#### 持久化值对象

在有可能的情况下，尽量根据领域模型来设计数据类型，而不是根绝数据模型来设计领域模型

### 领域服务(domain servcie)
领域中的服务表示一个无状态的操作，它用于实现特定于某个领域的服务。当某个操作事实和放在聚合和值对象上时， 最好的方式便是使用领域服务了。

不要将领域服务和应用服务混杂在一起了。在应用服务，不会处理业务逻辑，但是 领域服务却恰恰是处理业务逻辑的。

什么情况需要领域服务
- 执行一个显著的业务操作过程
- 对领域对象进行转换
- 以多个领域对象作为输入进行计算，结果产生一个值对象

### 领域事件

通常根绝命令操作的的方法的名字去命名领域事件

比如向一个冲刺提交一个待定项时，我们将发布领域事件：
命令方法: BackLogItem#CommitTo(Sprint aSprint)

事件输出： BacklogItemCommitted

在聚合发布事件时，应该使用事件的名字来反映过去发生的事，即该事件不是当前发生的，而是先前发生的。
除了正确的事件名，还需要一个时间戳来表示事件发生的事件，还有其他有意义的属性，比如是谁导致了领域事件的产生。


```
type BackLogItemCommitted struct {
	Date int64
	TenantId string
	BacklogItemId string
	SprintId string
}

func (b *BackLogItemCommitted) occurredOn() int64 {
	return b.Date
}

func (b *BackLogItemCommitted) setTenantId(tenantId string){
	b.TenantId = tenantId
}

func (b *BackLogItemCommitted) setBacklogItemId(bId string){
	b.BacklogItemId = bId
}

func (b *BackLogItemCommitted) setSprintId(sId string){
	b.SprintId = sId
}

```

#### 发布-订阅 （观察者模式）


### 聚合

一个事务只修改一个聚合实例
#### 原则1 设计小聚合


